/**CFile****************************************************************

  FileName    [extraUtilPrime.c]

  SystemName  [ABC: Logic synthesis and verification system.]

  PackageName [extra]

  Synopsis    [Function enumeration.]

  Author      [Alan Mishchenko]
  
  Affiliation [UC Berkeley]

  Date        [Ver. 1.0. Started - June 20, 2005.]

  Revision    [$Id: extraUtilPrime.c,v 1.0 2003/02/01 00:00:00 alanmi Exp $]

***********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "misc/vec/vec.h"
#include "misc/vec/vecHsh.h"
#include "bool/kit/kit.h"

ABC_NAMESPACE_IMPL_START

////////////////////////////////////////////////////////////////////////
///                        DECLARATIONS                              ///
////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
///                     FUNCTION DEFINITIONS                         ///
////////////////////////////////////////////////////////////////////////

/**Function*************************************************************

  Synopsis    []

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
void Abc_GenCountDump( Vec_Int_t * vPrimes, int nVars, char * pFileName )
{
    FILE * pFile;
    int i, k, Prime;
    pFile = fopen( pFileName, "wb" );
    fprintf( pFile, "# %d prime numbers up to 2^%d generated by ABC on %s\n", Vec_IntSize(vPrimes), nVars, Extra_TimeStamp() );
    fprintf( pFile, ".i %d\n", nVars );
    fprintf( pFile, ".o %d\n", 1 );
    fprintf( pFile, ".p %d\n", Vec_IntSize(vPrimes) );
    Vec_IntForEachEntry( vPrimes, Prime, i )
        for ( k = nVars-1; k >= 0; k-- )
            fprintf( pFile, "%d%s", (Prime >> k)&1, k ? "" : " 1\n" );
    fprintf( pFile, ".e\n\n" );
    fclose( pFile );
}

/**Function*************************************************************

  Synopsis    []

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
void Abc_GenCountHits1( Vec_Bit_t * vMap, Vec_Int_t * vPrimes, int nVars )
{
    abctime clk = Abc_Clock();
    int i, k, Prime, Count = 0;
    Vec_IntForEachEntry( vPrimes, Prime, i )
    {
        for ( k = 0; k < nVars; k++ )
            if ( !Vec_BitEntry(vMap, Prime ^ (1<<k)) )
            {
                //printf( "%3d : %2d %2d     flipped bit %d\n", Count, Prime, Prime ^ (1<<k), k );
                Count++;
            }
    }
    printf( "Dist1 pairs = %d. ", Count/2 );
    Abc_PrintTime( 1, "Time", Abc_Clock() - clk );
}
Vec_Int_t * Abc_GenPrimes( int nVars )
{
    int i, n, nBits = ( 1 << nVars );
    Vec_Bit_t * vMap = Vec_BitStart( nBits );
    Vec_Int_t * vPrimes = Vec_IntAlloc( 1000 );
    Vec_BitWriteEntry(vMap, 0, 1);
    Vec_BitWriteEntry(vMap, 1, 1);
    for ( n = 2; n < nBits; n++ )
        if ( !Vec_BitEntry(vMap, n) )
            for ( i = 2*n; i < nBits; i += n )
                Vec_BitWriteEntry(vMap, i, 1);
    for ( n = 2; n < nBits; n++ )
        if ( !Vec_BitEntry(vMap, n) )
            Vec_IntPush( vPrimes, n );
    printf( "Primes up to 2^%d = %d\n", nVars, Vec_IntSize(vPrimes) );
    Abc_GenCountHits1( vMap, vPrimes, nVars );
    Vec_BitFree( vMap );
    return vPrimes;
}
void Abc_GenPrimesTest()
{
    // 54,400,028 primes up to 2^30 can be computed in 22 sec
    int nVars = 18;
    Vec_Int_t * vPrimes = Abc_GenPrimes( nVars );
    Abc_GenCountDump( vPrimes, nVars, "primes18.pla" );
    //Vec_IntPrint( vPrimes );
    printf( "Primes up to 2^%d = %d\n", nVars, Vec_IntSize(vPrimes) );

    Vec_IntFree( vPrimes );
}



#define ABC_PRIME_MASK 0x3FF
static int s_1kPrimes[ABC_PRIME_MASK+1] = 
{
/*
    53,
    97,
    193,
    389,
    769,
    1543,
    3079,
    6151,
    12289,
    24593,
    49157,
    98317,
    196613,
    393241,
    786433,
    1572869,
    3145739,
    6291469,
    12582917,
    25165843,
    50331653,
    100663319,
    201326611,
    402653189,
    805306457,
    1610612741,
    0
*/
    901403,984877,908741,966307,924437,965639,918787,931067,982621,917669,981473,936407,990487,926077,922897,970861,
    942317,961747,979717,978947,940157,987821,981221,917713,983083,992231,928253,961187,991817,927643,923129,934291,
    998071,967567,961087,988661,910031,930481,904489,974167,941351,959911,963811,921463,900161,934489,905629,930653,
    901819,909457,939871,924083,915113,937969,928457,946291,973787,912869,994093,959279,905803,995219,949903,911011,
    986707,995053,930583,955511,928307,930889,968729,911507,949043,939359,961679,918041,937681,909091,963913,923539,
    929587,953347,917573,913037,995387,976483,986239,946949,922489,917887,957553,931529,929813,949567,941683,905161,
    928819,932417,900089,935903,926587,914467,967361,944833,945881,941741,915949,903407,904157,971863,993893,963607,
    918943,912463,980957,962963,968089,904513,963763,907363,904097,904093,991343,918347,986983,986659,935819,903569,
    929171,913933,999749,923123,961531,935861,915053,994853,943511,969923,927191,968333,949391,950959,968311,991409,
    911681,987101,904027,975259,907399,946223,907259,900409,957221,901063,974657,912337,979001,970147,982301,968213,
    923959,964219,935443,950161,989251,936127,985679,958159,930077,971899,944857,956083,914293,941981,909481,909047,
    960527,958183,970687,914827,949051,928159,933551,964423,914041,915869,929953,901367,914219,975551,912391,917809,
    991499,904781,949153,959887,961957,970943,947741,941263,984541,951437,984301,947423,905761,964913,971357,927709,
    916441,941933,956993,988243,921197,905453,922081,950813,946331,998561,929023,937421,956231,907651,977897,905491,
    960173,931837,955217,911951,990643,971021,949439,988453,996781,951497,906011,944309,911293,917123,983803,928097,
    977747,928703,949957,919189,925513,923953,904997,986351,930689,902009,912007,906757,955793,926803,906809,962743,
    911917,909329,949021,974651,959083,945367,905137,948377,931757,945409,920279,915007,960121,920609,946163,946391,
    928903,932951,944329,901529,959809,918469,978643,911159,982573,965411,962233,911269,953273,974437,907589,992269,
    929399,980431,905693,968267,970481,911089,950557,913799,920407,974489,909863,918529,975277,929323,971549,969181,
    972787,964267,939971,943763,940483,971501,921637,945341,955211,920701,978349,969041,929861,904103,908539,995369,
    995567,917471,908879,993821,947783,954599,978463,914519,942869,947263,988343,914657,956987,903641,943343,991063,
    985403,926327,982829,958439,942017,960353,944987,934793,948971,999331,990767,915199,912211,946459,997019,965059,
    924907,983233,943273,945359,919613,933883,928927,942763,994087,996211,918971,924871,938491,957139,918839,914629,
    974329,900577,952823,941641,900461,946997,983123,935149,923693,908419,995651,912871,987067,920201,913921,929209,
    962509,974599,972001,920273,922099,951781,958549,909971,975133,937207,929941,961397,980677,923579,980081,942199,
    940319,942979,912349,942691,986989,947711,972343,932663,937877,940369,919571,927187,981439,932353,952313,915947,
    915851,974041,989381,921029,997013,999199,914801,918751,997327,992843,982133,932051,964861,903979,937463,916781,
    944389,986719,958369,961451,917767,954367,949853,934939,958807,975797,949699,957097,980773,969989,934907,909281,
    904679,909833,991741,946769,908381,932447,957889,981697,905701,919033,999023,993541,912953,911719,934603,925019,
    989341,912269,917789,981049,959149,989909,960521,952183,922627,936253,910957,972047,945037,940399,928313,928471,
    962459,959947,927541,917333,926899,911837,985631,955127,922729,911171,900511,926251,918209,943477,955277,959773,
    971039,917353,955313,930301,990799,957731,917519,938507,988111,911657,999721,968917,934537,903073,921703,966227,
    904661,998213,954307,931309,909331,933643,910099,958627,914533,902903,950149,972721,915157,969037,988219,944137,
    976411,952873,964787,970927,968963,920741,975187,966817,982909,975281,931907,959267,980711,924617,975691,962309,
    976307,932209,989921,907969,947927,932207,945397,948929,904903,938563,961691,977671,963173,927149,951061,966547,
    937661,983597,948139,948041,982759,941093,993703,910097,902347,990307,978217,996763,904919,924641,902299,929549,
    977323,975071,932917,996293,925579,925843,915487,917443,999541,943043,919109,959879,912173,986339,939193,939599,
    927077,977183,966521,959471,991943,985951,942187,932557,904297,972337,931751,964097,942341,966221,929113,960131,
    906427,970133,996511,925637,971651,983443,981703,933613,939749,929029,958043,961511,957241,901079,950479,975493,
    985799,909401,945601,911077,978359,948151,950333,968879,978727,961151,957823,950393,960293,915683,971513,915659,
    943841,902477,916837,911161,958487,963691,949607,935707,987607,901613,972557,938947,931949,919021,982217,914737,
    913753,971279,981683,915631,907807,970421,983173,916099,984587,912049,981391,947747,966233,932101,991733,969757,
    904283,996601,979807,974419,964693,931537,917251,967961,910093,989321,988129,997307,963427,999221,962447,991171,
    993137,914339,964973,908617,968567,920497,980719,949649,912239,907367,995623,906779,914327,918131,983113,962993,
    977849,914941,932681,905713,932579,923977,965507,916469,984119,931981,998423,984407,993841,901273,910799,939847,
    997153,971429,994927,912631,931657,968377,927833,920149,978041,947449,993233,927743,939737,975017,961861,984539,
    938857,977437,950921,963659,923917,932983,922331,982393,983579,935537,914357,973051,904531,962077,990281,989231,
    910643,948281,961141,911839,947413,923653,982801,903883,931943,930617,928679,962119,969977,926921,999773,954181,
    963019,973411,918139,959719,918823,941471,931883,925273,918173,949453,946993,945457,959561,968857,935603,978283,
    978269,947389,931267,902599,961189,947621,920039,964049,947603,913259,997811,943843,978277,972119,929431,918257,
    991663,954043,910883,948797,929197,985057,990023,960961,967139,923227,923371,963499,961601,971591,976501,989959,
    908731,951331,989887,925307,909299,949159,913447,969797,959449,976957,906617,901213,922667,953731,960199,960049,
    985447,942061,955613,965443,947417,988271,945887,976369,919823,971353,962537,929963,920473,974177,903649,955777,
    963877,973537,929627,994013,940801,985709,995341,936319,904681,945817,996617,953191,952859,934889,949513,965407,
    988357,946801,970391,953521,905413,976187,968419,940669,908591,976439,915731,945473,948517,939181,935183,978067,
    907663,967511,968111,981599,913907,933761,994933,980557,952073,906557,935621,914351,967903,949129,957917,971821,
    925937,926179,955729,966871,960737,968521,949997,956999,961273,962683,990377,908851,932231,929749,932149,966971,
    922079,978149,938453,958313,995381,906259,969503,922321,918947,972443,916411,935021,944429,928643,952199,918157,
    917783,998497,944777,917771,936731,999953,975157,908471,989557,914189,933787,933157,938953,922931,986569,964363,
    906473,963419,941467,946079,973561,957431,952429,965267,978473,924109,979529,991901,988583,918259,961991,978037,
    938033,949967,986071,986333,974143,986131,963163,940553,950933,936587,923407,950357,926741,959099,914891,976231,
    949387,949441,943213,915353,983153,975739,934243,969359,926557,969863,961097,934463,957547,916501,904901,928231,
    903673,974359,932219,916933,996019,934399,955813,938089,907693,918223,969421,940903,940703,913027,959323,940993,
    937823,906691,930841,923701,933259,911959,915601,960251,985399,914359,930827,950251,975379,903037,905783,971237
};

#define TAB_UNUSED 0xFFFF

typedef struct Tab_Man_t_ Tab_Man_t;
typedef struct Tab_Ent_t_ Tab_Ent_t;
struct Tab_Man_t_
{
    int         nVars;
    int         nCubes;
    int *       pCubes;   // pointers to cubes
    int *       pValues;  // hash values
    Tab_Ent_t * pTable;   // hash table (lits -> cube + lit + lit)
    int         Degree;   // degree of 2 larger than log2(nCubes)
    int         Mask;     // table size (2^Degree)
    int         nEnts;    // number of entries
};
struct Tab_Ent_t_
{
    int         Table;
    int         Cube;
    unsigned    VarA : 16;
    unsigned    VarB : 16;
    int         Next;
};

static inline int * Tab_ManCube( Tab_Man_t * p, int i ) { return p->pCubes + i * (p->nVars + 1); }
static inline int   Tab_ManValue( Tab_Man_t * p, int a )
{
    return (a + 53) * s_1kPrimes[a];
}
static inline int   Tab_ManFinal( Tab_Man_t * p, int a )
{
//    return (a ^ (a >> p->Degree)) & p->Mask;
    return a & p->Mask;
}
static inline int   Tab_ManHashValue( Tab_Man_t * p, int * pCube )
{
    unsigned Value = 0; int i;
    for ( i = 1; i <= pCube[0]; i++ )
        Value += Tab_ManValue( p, pCube[i] );
    return Value;
}
static inline void  Tab_ManHashAdd( Tab_Man_t * p, int Value, int Cube, int VarA, int VarB )
{
    Tab_Ent_t * pCell = p->pTable + p->nEnts;
    Tab_Ent_t * pBin  = p->pTable + Value;
    if ( pBin->Table )
        pCell->Next = pBin->Table;
    pBin->Table = p->nEnts++;
    pCell->Cube = Cube;
    pCell->VarA = VarA;
    pCell->VarB = VarB;
}
static inline void  Tab_ManPrintCube( Tab_Man_t * p, int c, int Var )
{
    int i, * pCube = Tab_ManCube( p, c );
    for ( i = 1; i <= pCube[0]; i++ )
        if ( i == Var + 1 )
            printf( "-" );
        else
            printf( "%d", !Abc_LitIsCompl(pCube[i]) );
}
static inline void  Tab_ManPrintEntry( Tab_Man_t * p, int e )
{
    printf( "Entry %4d : ", e );
    printf( "%3d   ", p->pTable[e].Cube );
    Tab_ManPrintCube( p, p->pTable[e].Cube, p->pTable[e].VarA );
    printf( "   " );
    if ( p->pTable[e].VarA != 0xFFFF )
        printf( "%2d ", p->pTable[e].VarA );
    else
        printf( "   " );
    if ( p->pTable[e].VarB != 0xFFFF )
        printf( "%2d ", p->pTable[e].VarB );
    else
        printf( "   " );
    printf( "\n" );
}

/**Function*************************************************************

  Synopsis    [Table decomposition.]

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
Tab_Man_t * Tab_ManAlloc( int nVars, int nCubes )
{
    Tab_Man_t * p = ABC_CALLOC( Tab_Man_t, 1 );
    p->nVars   = nVars;
    p->nCubes  = nCubes;
    p->Degree  = Abc_Base2Log((p->nVars + 1) * p->nCubes + 1) + 3;
    p->Mask    = (1 << p->Degree) - 1;
    p->nEnts   = 1;
    p->pCubes  = ABC_ALLOC( int, p->nCubes * (p->nVars + 1) );
    p->pValues = ABC_ALLOC( int, p->nCubes );
    p->pTable  = ABC_CALLOC( Tab_Ent_t, (p->Mask + 1) );
    printf( "Allocated %.2f MB for table with %d entries (degree %d) (expected %d).\n", 16.0 * (p->Mask + 1) / (1 << 20), p->Mask + 1, p->Degree, p->nCubes * (p->nVars + 1) );
    return p;
}
void Tab_ManFree( Tab_Man_t * p )
{
    ABC_FREE( p->pCubes );
    ABC_FREE( p->pValues );
    ABC_FREE( p->pTable );
    ABC_FREE( p );
}
void Tab_ManStart( Tab_Man_t * p, Vec_Int_t * vCubes )
{
    int Count0 = 0, Count1 = 0, Count2 = 0, Count3 = 0;
    int * pCube, Cube, c, v;
    Vec_IntForEachEntry( vCubes, Cube, c )
    {
        pCube = Tab_ManCube( p, c );
        pCube[0] = p->nVars;
        for ( v = 0; v < p->nVars; v++ )
            pCube[v+1] = Abc_Var2Lit( v, !((Cube >> v) & 1) );
        p->pValues[c] = Tab_ManHashValue( p, pCube );
        Tab_ManHashAdd( p, Tab_ManFinal(p, p->pValues[c]), c, TAB_UNUSED, TAB_UNUSED );
        // add distance-1 
        for ( v = 0; v < p->nVars; v++ )
            Tab_ManHashAdd( p, Tab_ManFinal(p, p->pValues[c] - Tab_ManValue(p, pCube[v+1])), c, v, TAB_UNUSED );
//printf( "%3d : %3d  ", c, Cube );
//Tab_ManPrintCube( p, c, TAB_UNUSED );
//printf( "\n" );
    }
    // count empty cell, one-entry cells, and multi-entry cells
    for ( v = 0; v <= p->Mask; v++ )
    {
/*
        int i, iStart = p->pTable[v].Table;
        for ( i = 0; iStart; i++, iStart = p->pTable[iStart].Next );
        printf( "%d ", i );
*/
/*
        if ( v < 100 )
        {
            int i, iStart = p->pTable[v].Table;
            if ( iStart )
                printf( "\nBin %d\n", v );
            for ( i = 0; iStart; i++, iStart = p->pTable[iStart].Next )
                Tab_ManPrintEntry( p, iStart );
        }
*/
        if ( p->pTable[v].Table == 0 )
            Count0++;
        else if ( p->pTable[p->pTable[v].Table].Next == 0 )
            Count1++;
        else if ( p->pTable[p->pTable[p->pTable[v].Table].Next].Next == 0 )
            Count2++;
        else
            Count3++;
    }
    printf( "0 = %d.  1 = %d.  2 = %d.  3+ = %d.\n", Count0, Count1, Count2, Count3 );
}


/**Function*************************************************************

  Synopsis    [Table decomposition.]

  Description []
               
  SideEffects []

  SeeAlso     []

***********************************************************************/
void Tab_DecomposeTest()
{
    int nVars = 20;// no more than 13
    abctime clk = Abc_Clock();
    Vec_Int_t * vPrimes = Abc_GenPrimes( nVars );
    Tab_Man_t * p = Tab_ManAlloc( nVars, Vec_IntSize(vPrimes) );
    Tab_ManStart( p, vPrimes );
    printf( "Added %d entries.\n", p->nEnts );
    Tab_ManFree( p );
    Vec_IntFree( vPrimes );
    Abc_PrintTime( 1, "Time", Abc_Clock() - clk );
}


////////////////////////////////////////////////////////////////////////
///                       END OF FILE                                ///
////////////////////////////////////////////////////////////////////////


ABC_NAMESPACE_IMPL_END

